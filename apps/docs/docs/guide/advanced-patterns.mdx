---
sidebar_position: 5
---

import { Input } from 'rizzui/input';
import { Select } from 'rizzui/select';
import { Button } from 'rizzui/button';
import { Modal } from 'rizzui/modal';
import { Textarea } from 'rizzui/textarea';
import { Checkbox } from 'rizzui/checkbox';
import { Switch } from 'rizzui/switch';
import Paper from '@site/src/components/paper';
import { useState, useCallback, useMemo } from 'react';
import { MagnifyingGlassIcon, CurrencyDollarIcon } from '@heroicons/react/24/outline';

# Advanced Patterns

Learn advanced patterns and real-world use cases for building production-ready applications with RizzUI components.

<div className="mb-20 md:mb-28" />

## Debounced Search Input

Implement a search input with debouncing to reduce API calls and improve performance.

```tsx
'use client';

import { useState, useEffect } from 'react';
import { Input } from 'rizzui/input';
import { MagnifyingGlassIcon } from '@heroicons/react/24/outline';

function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export default function DebouncedSearch() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // Perform API call or search operation
      console.log('Searching for:', debouncedSearchTerm);
      // fetchSearchResults(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <Input
      type="search"
      label="Search"
      placeholder="Type to search..."
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      prefix={<MagnifyingGlassIcon className="h-5 w-5" />}
      clearable
      onClear={() => setSearchTerm('')}
    />
  );
}
```

**Key Benefits:**
- Reduces API calls by waiting for user to finish typing
- Improves performance and reduces server load
- Better user experience with smoother interactions

<div className="mb-16" />

## Currency Input with Formatting

Create a currency input that formats values as the user types.

```tsx
'use client';

import { useState } from 'react';
import { Input } from 'rizzui/input';
import { CurrencyDollarIcon } from '@heroicons/react/24/outline';

export default function CurrencyInput() {
  const [value, setValue] = useState('');

  const formatCurrency = (input: string) => {
    // Remove all non-digit characters
    const numbers = input.replace(/\D/g, '');
    
    if (!numbers) return '';
    
    // Format as currency (cents to dollars)
    const dollars = (parseInt(numbers) / 100).toFixed(2);
    
    // Add thousand separators
    return dollars.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const formatted = formatCurrency(e.target.value);
    setValue(formatted);
  };

  return (
    <Input
      type="text"
      label="Amount"
      placeholder="$0.00"
      value={value ? `$${value}` : ''}
      onChange={handleChange}
      prefix={<CurrencyDollarIcon className="h-5 w-5" />}
      helperText="Enter amount in dollars"
    />
  );
}
```

<div className="mb-16" />

## Async Select with Loading State

Implement a Select component that loads options asynchronously from an API.

```tsx
'use client';

import { useState, useEffect } from 'react';
import { Select, type SelectOption } from 'rizzui/select';
import { Loader } from 'rizzui/loader';

interface User {
  id: number;
  name: string;
  email: string;
}

export default function AsyncSelect() {
  const [options, setOptions] = useState<SelectOption[]>([]);
  const [loading, setLoading] = useState(false);
  const [value, setValue] = useState<string | null>(null);

  useEffect(() => {
    const fetchUsers = async () => {
      setLoading(true);
      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const mockUsers: User[] = [
          { id: 1, name: 'John Doe', email: 'john@example.com' },
          { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
          { id: 3, name: 'Bob Johnson', email: 'bob@example.com' },
        ];

        const selectOptions: SelectOption[] = mockUsers.map(user => ({
          label: `${user.name} (${user.email})`,
          value: user.id.toString(),
        }));

        setOptions(selectOptions);
      } catch (error) {
        console.error('Failed to fetch users:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  return (
    <Select
      label="Select User"
      value={value}
      options={loading ? [] : options}
      onChange={setValue}
      placeholder={loading ? 'Loading users...' : 'Select a user'}
      disabled={loading}
      suffix={loading ? <Loader size="sm" /> : undefined}
      displayValue={(selected) => {
        const option = options.find(opt => opt.value === selected);
        return option?.label ?? '';
      }}
    />
  );
}
```

<div className="mb-16" />

## Multi-Step Form with Validation

Create a multi-step form with step validation and progress tracking.

```tsx
'use client';

import { useState } from 'react';
import { Input } from 'rizzui/input';
import { Textarea } from 'rizzui/textarea';
import { Button } from 'rizzui/button';
import { Stepper } from 'rizzui/stepper';
import { Checkbox } from 'rizzui/checkbox';

type FormData = {
  name: string;
  email: string;
  message: string;
  agree: boolean;
};

export default function MultiStepForm() {
  const [currentStep, setCurrentStep] = useState(1);
  const [formData, setFormData] = useState<FormData>({
    name: '',
    email: '',
    message: '',
    agree: false,
  });
  const [errors, setErrors] = useState<Partial<Record<keyof FormData, string>>>({});

  const steps = [
    { title: 'Personal Info', description: 'Your details' },
    { title: 'Message', description: 'Your message' },
    { title: 'Review', description: 'Confirm' },
  ];

  const validateStep = (step: number): boolean => {
    const newErrors: Partial<Record<keyof FormData, string>> = {};

    if (step === 1) {
      if (!formData.name.trim()) {
        newErrors.name = 'Name is required';
      }
      if (!formData.email.trim()) {
        newErrors.email = 'Email is required';
      } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
        newErrors.email = 'Invalid email format';
      }
    }

    if (step === 2) {
      if (!formData.message.trim()) {
        newErrors.message = 'Message is required';
      }
    }

    if (step === 3) {
      if (!formData.agree) {
        newErrors.agree = 'You must agree to continue';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleNext = () => {
    if (validateStep(currentStep)) {
      setCurrentStep(prev => Math.min(prev + 1, steps.length));
    }
  };

  const handlePrevious = () => {
    setCurrentStep(prev => Math.max(prev - 1, 1));
  };

  const handleSubmit = () => {
    if (validateStep(3)) {
      console.log('Form submitted:', formData);
      alert('Form submitted successfully!');
    }
  };

  return (
    <div className="w-full max-w-2xl space-y-6">
      <Stepper current={currentStep} className="mb-8">
        {steps.map((step, index) => (
          <Stepper.Step key={index} title={step.title} description={step.description} />
        ))}
      </Stepper>

      <div className="space-y-4">
        {currentStep === 1 && (
          <>
            <Input
              label="Name"
              placeholder="Enter your name"
              value={formData.name}
              onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
              error={errors.name}
            />
            <Input
              type="email"
              label="Email"
              placeholder="Enter your email"
              value={formData.email}
              onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
              error={errors.email}
            />
          </>
        )}

        {currentStep === 2 && (
          <Textarea
            label="Message"
            placeholder="Enter your message"
            value={formData.message}
            onChange={(e) => setFormData(prev => ({ ...prev, message: e.target.value }))}
            error={errors.message}
            rows={6}
          />
        )}

        {currentStep === 3 && (
          <div className="space-y-4">
            <div className="p-4 bg-gray-50 dark:bg-gray-800 rounded-lg space-y-2">
              <p><strong>Name:</strong> {formData.name}</p>
              <p><strong>Email:</strong> {formData.email}</p>
              <p><strong>Message:</strong> {formData.message}</p>
            </div>
            <Checkbox
              label="I agree to the terms and conditions"
              checked={formData.agree}
              onChange={(e) => setFormData(prev => ({ ...prev, agree: e.target.checked }))}
              error={errors.agree}
            />
          </div>
        )}
      </div>

      <div className="flex justify-between">
        <Button
          variant="outline"
          onClick={handlePrevious}
          disabled={currentStep === 1}
        >
          Previous
        </Button>
        {currentStep < steps.length ? (
          <Button onClick={handleNext}>Next</Button>
        ) : (
          <Button onClick={handleSubmit}>Submit</Button>
        )}
      </div>
    </div>
  );
}
```

<div className="mb-16" />

## Conditional Form Fields

Show or hide form fields based on user selections.

```tsx
'use client';

import { useState } from 'react';
import { Input } from 'rizzui/input';
import { Select, type SelectOption } from 'rizzui/select';
import { Textarea } from 'rizzui/textarea';
import { Switch } from 'rizzui/switch';

export default function ConditionalFields() {
  const [accountType, setAccountType] = useState<string | null>(null);
  const [isBusiness, setIsBusiness] = useState(false);

  const accountOptions: SelectOption[] = [
    { label: 'Personal', value: 'personal' },
    { label: 'Business', value: 'business' },
    { label: 'Enterprise', value: 'enterprise' },
  ];

  return (
    <div className="w-full max-w-md space-y-4">
      <Select
        label="Account Type"
        value={accountType}
        options={accountOptions}
        onChange={setAccountType}
        placeholder="Select account type"
      />

      <Input
        label="Email"
        type="email"
        placeholder="your@email.com"
      />

      {accountType === 'business' && (
        <>
          <Input
            label="Company Name"
            placeholder="Enter company name"
          />
          <Input
            label="Tax ID"
            placeholder="Enter tax ID"
          />
        </>
      )}

      {accountType === 'enterprise' && (
        <>
          <Input
            label="Company Name"
            placeholder="Enter company name"
          />
          <Input
            label="Tax ID"
            placeholder="Enter tax ID"
          />
          <Switch
            label="Enable advanced features"
            checked={isBusiness}
            onChange={(e) => setIsBusiness(e.target.checked)}
          />
          {isBusiness && (
            <Textarea
              label="Additional Requirements"
              placeholder="Describe your requirements"
              rows={4}
            />
          )}
        </>
      )}
    </div>
  );
}
```

<div className="mb-16" />

## Confirmation Modal Pattern

Create reusable confirmation modals for destructive actions.

```tsx
'use client';

import { useState } from 'react';
import { Modal } from 'rizzui/modal';
import { Button } from 'rizzui/button';
import { Text } from 'rizzui/typography';

interface ConfirmationModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'danger' | 'default';
}

function ConfirmationModal({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  variant = 'default',
}: ConfirmationModalProps) {
  const handleConfirm = () => {
    onConfirm();
    onClose();
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      <div className="p-6">
        <Text className="text-lg font-semibold mb-2">{title}</Text>
        <Text className="text-gray-600 dark:text-gray-400 mb-6">{message}</Text>
        <div className="flex justify-end gap-3">
          <Button variant="outline" onClick={onClose}>
            {cancelText}
          </Button>
          <Button
            variant={variant === 'danger' ? 'solid' : 'solid'}
            color={variant === 'danger' ? 'danger' : 'primary'}
            onClick={handleConfirm}
          >
            {confirmText}
          </Button>
        </div>
      </div>
    </Modal>
  );
}

export default function ConfirmationExample() {
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [isArchiveModalOpen, setIsArchiveModalOpen] = useState(false);

  const handleDelete = () => {
    console.log('Item deleted');
    // Perform delete operation
  };

  const handleArchive = () => {
    console.log('Item archived');
    // Perform archive operation
  };

  return (
    <div className="space-y-4">
      <Button
        variant="solid"
        color="danger"
        onClick={() => setIsDeleteModalOpen(true)}
      >
        Delete Item
      </Button>

      <Button
        variant="outline"
        onClick={() => setIsArchiveModalOpen(true)}
      >
        Archive Item
      </Button>

      <ConfirmationModal
        isOpen={isDeleteModalOpen}
        onClose={() => setIsDeleteModalOpen(false)}
        onConfirm={handleDelete}
        title="Delete Item"
        message="Are you sure you want to delete this item? This action cannot be undone."
        confirmText="Delete"
        variant="danger"
      />

      <ConfirmationModal
        isOpen={isArchiveModalOpen}
        onClose={() => setIsArchiveModalOpen(false)}
        onConfirm={handleArchive}
        title="Archive Item"
        message="This item will be moved to the archive. You can restore it later."
        confirmText="Archive"
      />
    </div>
  );
}
```

<div className="mb-16" />

## Form with Real-time Validation

Implement form validation that provides immediate feedback as users type.

```tsx
'use client';

import { useState } from 'react';
import { Input } from 'rizzui/input';
import { Button } from 'rizzui/button';

interface ValidationRules {
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  custom?: (value: string) => string | null;
}

function useFieldValidation(value: string, rules: ValidationRules) {
  const [error, setError] = useState<string | null>(null);

  const validate = useCallback(() => {
    if (rules.required && !value.trim()) {
      setError('This field is required');
      return false;
    }

    if (rules.minLength && value.length < rules.minLength) {
      setError(`Minimum length is ${rules.minLength} characters`);
      return false;
    }

    if (rules.maxLength && value.length > rules.maxLength) {
      setError(`Maximum length is ${rules.maxLength} characters`);
      return false;
    }

    if (rules.pattern && !rules.pattern.test(value)) {
      setError('Invalid format');
      return false;
    }

    if (rules.custom) {
      const customError = rules.custom(value);
      if (customError) {
        setError(customError);
        return false;
      }
    }

    setError(null);
    return true;
  }, [value, rules]);

  return { error, validate };
}

export default function RealTimeValidation() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const usernameValidation = useFieldValidation(username, {
    required: true,
    minLength: 3,
    maxLength: 20,
    pattern: /^[a-zA-Z0-9_]+$/,
    custom: (value) => {
      if (value === 'admin') {
        return 'Username "admin" is reserved';
      }
      return null;
    },
  });

  const passwordValidation = useFieldValidation(password, {
    required: true,
    minLength: 8,
    custom: (value) => {
      if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(value)) {
        return 'Password must contain uppercase, lowercase, and number';
      }
      return null;
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const isUsernameValid = usernameValidation.validate();
    const isPasswordValid = passwordValidation.validate();

    if (isUsernameValid && isPasswordValid) {
      console.log('Form is valid');
      // Submit form
    }
  };

  return (
    <form onSubmit={handleSubmit} className="w-full max-w-md space-y-4">
      <Input
        label="Username"
        placeholder="Enter username"
        value={username}
        onChange={(e) => {
          setUsername(e.target.value);
          usernameValidation.validate();
        }}
        onBlur={usernameValidation.validate}
        error={usernameValidation.error}
        helperText="3-20 characters, letters, numbers, and underscores only"
      />

      <Input
        type="password"
        label="Password"
        placeholder="Enter password"
        value={password}
        onChange={(e) => {
          setPassword(e.target.value);
          passwordValidation.validate();
        }}
        onBlur={passwordValidation.validate}
        error={passwordValidation.error}
        helperText="At least 8 characters with uppercase, lowercase, and number"
      />

      <Button type="submit" className="w-full">
        Submit
      </Button>
    </form>
  );
}
```

<div className="mb-16" />

## Performance Tips

### 1. Memoize Expensive Computations

Use `useMemo` for expensive option transformations:

```tsx
const formattedOptions = useMemo(() => {
  return rawData.map(item => ({
    label: `${item.firstName} ${item.lastName}`,
    value: item.id,
  }));
}, [rawData]);
```

### 2. Debounce Search Inputs

Always debounce search inputs to reduce API calls:

```tsx
const debouncedSearch = useDebounce(searchTerm, 300);
```

### 3. Lazy Load Options

For large option lists, consider virtual scrolling or pagination:

```tsx
// Load options in chunks
const loadMoreOptions = async () => {
  const nextPage = currentPage + 1;
  const newOptions = await fetchOptions(nextPage);
  setOptions(prev => [...prev, ...newOptions]);
};
```

### 4. Avoid Unnecessary Re-renders

Use `React.memo` for expensive components:

```tsx
const ExpensiveComponent = React.memo(({ data }) => {
  // Component implementation
});
```

### 5. Optimize Form State

Use form libraries like React Hook Form for better performance:

```tsx
// React Hook Form only re-renders changed fields
const { register, handleSubmit } = useForm();
```

---

These patterns provide a solid foundation for building production-ready applications with RizzUI. Adapt them to your specific use cases and requirements.

