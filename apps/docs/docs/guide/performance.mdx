---
sidebar_position: 6
---

# Performance Tips

Optimize your RizzUI applications for better performance and user experience.

<div className="mb-20 md:mb-28" />

## Component Optimization

### 1. Memoize Expensive Computations

Use `useMemo` for expensive option transformations and data processing:

```tsx
'use client';

import { useMemo } from 'react';
import { Select, type SelectOption } from 'rizzui/select';

interface User {
  id: number;
  firstName: string;
  lastName: string;
  email: string;
}

export default function OptimizedSelect({ users }: { users: User[] }) {
  // Memoize the transformation to avoid recalculation on every render
  const options: SelectOption[] = useMemo(() => {
    return users.map(user => ({
      label: `${user.firstName} ${user.lastName} (${user.email})`,
      value: user.id.toString(),
    }));
  }, [users]); // Only recalculate when users array changes

  return <Select options={options} />;
}
```

**Benefits:**
- Prevents unnecessary recalculations
- Reduces render time
- Improves component responsiveness

<div className="mb-16" />

### 2. Debounce Search Inputs

Always debounce search inputs to reduce API calls and improve performance:

```tsx
'use client';

import { useState, useEffect } from 'react';
import { Input } from 'rizzui/input';

function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export default function DebouncedSearch() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // API call only happens after user stops typing for 300ms
      fetchSearchResults(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <Input
      type="search"
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

**Recommended delays:**
- Search inputs: 300-500ms
- Autocomplete: 200-300ms
- Form validation: 500-1000ms

<div className="mb-16" />

### 3. Lazy Load Options

For large option lists, implement pagination or virtual scrolling:

```tsx
'use client';

import { useState, useCallback } from 'react';
import { Select, type SelectOption } from 'rizzui/select';

export default function PaginatedSelect() {
  const [options, setOptions] = useState<SelectOption[]>([]);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);

  const loadMoreOptions = useCallback(async () => {
    if (loading || !hasMore) return;

    setLoading(true);
    try {
      const newOptions = await fetchOptions(page);
      setOptions(prev => [...prev, ...newOptions]);
      setHasMore(newOptions.length === 20); // Assuming 20 items per page
      setPage(prev => prev + 1);
    } catch (error) {
      console.error('Failed to load options:', error);
    } finally {
      setLoading(false);
    }
  }, [page, loading, hasMore]);

  return (
    <Select
      options={options}
      onSearchChange={(search) => {
        // Reset and reload when search changes
        setOptions([]);
        setPage(1);
        loadMoreOptions();
      }}
      // Add "Load More" option at the end
      // This would require custom rendering
    />
  );
}
```

<div className="mb-16" />

### 4. Avoid Unnecessary Re-renders

Use `React.memo` for expensive components that receive stable props:

```tsx
'use client';

import React, { memo } from 'react';
import { Input } from 'rizzui/input';

interface ExpensiveInputProps {
  value: string;
  onChange: (value: string) => void;
  // Other stable props
}

// Memoize to prevent re-renders when parent re-renders
const ExpensiveInput = memo(({ value, onChange }: ExpensiveInputProps) => {
  // Expensive computation or rendering logic
  return (
    <Input
      value={value}
      onChange={(e) => onChange(e.target.value)}
      // ... other props
    />
  );
});

ExpensiveInput.displayName = 'ExpensiveInput';

export default ExpensiveInput;
```

<div className="mb-16" />

## Form Performance

### 1. Use React Hook Form

React Hook Form minimizes re-renders by only updating changed fields:

```tsx
'use client';

import { useForm } from 'react-hook-form';
import { Input } from 'rizzui/input';
import { Button } from 'rizzui/button';

export default function OptimizedForm() {
  // React Hook Form only re-renders changed fields
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = (data: any) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Only this input re-renders when its value changes */}
      <Input
        {...register('email')}
        error={errors.email?.message}
      />
      <Input
        {...register('name')}
        error={errors.name?.message}
      />
      <Button type="submit">Submit</Button>
    </form>
  );
}
```

**Benefits:**
- Minimal re-renders
- Better performance for large forms
- Built-in validation support

<div className="mb-16" />

### 2. Optimize Form State Management

Avoid storing form state in a single object if only a few fields change frequently:

```tsx
// ❌ Bad: Entire form re-renders on any field change
const [formData, setFormData] = useState({
  name: '',
  email: '',
  address: '',
  // ... many more fields
});

// ✅ Good: Use React Hook Form or separate state for frequently changing fields
const { register, handleSubmit } = useForm();
```

<div className="mb-16" />

### 3. Batch State Updates

Use functional updates to batch state changes:

```tsx
'use client';

import { useState } from 'react';
import { Input } from 'rizzui/input';

export default function BatchedUpdates() {
  const [formData, setFormData] = useState({ name: '', email: '' });

  // ✅ Good: Functional update ensures latest state
  const handleChange = (field: string, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  return (
    <>
      <Input
        value={formData.name}
        onChange={(e) => handleChange('name', e.target.value)}
      />
      <Input
        value={formData.email}
        onChange={(e) => handleChange('email', e.target.value)}
      />
    </>
  );
}
```

<div className="mb-16" />

## List Rendering

### 1. Virtualize Long Lists

For long lists of options or data, use virtualization:

```tsx
'use client';

import { useMemo } from 'react';
import { Select, type SelectOption } from 'rizzui/select';

export default function VirtualizedSelect({ items }: { items: any[] }) {
  // Only render visible items
  const visibleOptions = useMemo(() => {
    // Implement virtualization logic or use a library like react-window
    return items.slice(0, 50).map(item => ({
      label: item.name,
      value: item.id,
    }));
  }, [items]);

  return <Select options={visibleOptions} />;
}
```

**Libraries to consider:**
- `react-window` - Lightweight virtualization
- `react-virtualized` - Feature-rich virtualization
- `@tanstack/react-virtual` - Modern virtualization solution

<div className="mb-16" />

### 2. Use Keys Properly

Always use stable, unique keys for list items:

```tsx
// ✅ Good: Use stable IDs
{items.map(item => (
  <SelectOption key={item.id} value={item.id} label={item.name} />
))}

// ❌ Bad: Using index as key
{items.map((item, index) => (
  <SelectOption key={index} value={item.id} label={item.name} />
))}
```

<div className="mb-16" />

## Bundle Size Optimization

### 1. Tree-Shake Imports

Import components individually to enable tree-shaking:

```tsx
// ✅ Good: Tree-shakeable imports
import { Input } from 'rizzui/input';
import { Button } from 'rizzui/button';
import { Select } from 'rizzui/select';

// ❌ Bad: Imports entire library
import { Input, Button, Select } from 'rizzui';
```

<div className="mb-16" />

### 2. Code Splitting

Use dynamic imports for components that aren't immediately needed:

```tsx
'use client';

import { lazy, Suspense } from 'react';
import { Loader } from 'rizzui/loader';

// Lazy load heavy components
const HeavyModal = lazy(() => import('./HeavyModal'));

export default function App() {
  return (
    <Suspense fallback={<Loader />}>
      <HeavyModal />
    </Suspense>
  );
}
```

<div className="mb-16" />

## Best Practices Summary

### ✅ Do's

- **Debounce search inputs** - Reduce API calls
- **Memoize expensive computations** - Use `useMemo` for transformations
- **Use React Hook Form** - Minimize form re-renders
- **Virtualize long lists** - Improve rendering performance
- **Tree-shake imports** - Reduce bundle size
- **Use stable keys** - Optimize list rendering
- **Batch state updates** - Reduce re-renders

### ❌ Don'ts

- **Don't store all form state in one object** - Causes unnecessary re-renders
- **Don't use index as keys** - Breaks React's reconciliation
- **Don't import entire library** - Increases bundle size
- **Don't skip debouncing** - Causes excessive API calls
- **Don't render all options at once** - Use pagination or virtualization

<div className="mb-16" />

## Performance Monitoring

### Measure Before Optimizing

Use React DevTools Profiler to identify performance bottlenecks:

1. Open React DevTools
2. Go to Profiler tab
3. Record a session
4. Identify components with long render times
5. Optimize those components

### Key Metrics to Monitor

- **Render time** - Time spent rendering components
- **Re-render frequency** - How often components re-render
- **Bundle size** - Total JavaScript bundle size
- **API calls** - Number of API requests per action

---

Following these performance tips will help you build fast, responsive applications with RizzUI. Always measure performance before and after optimizations to ensure improvements.

